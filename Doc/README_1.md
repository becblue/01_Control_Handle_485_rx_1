# STM32F103 

## 1. 项目概述
本项目是一个基于STM32F103C8T6的Modbus RTU通讯系统的B站开发项目。该系统网络拓扑采用主从架构，A为主站，B为从站。A站可主动发起通信；B站只作应答
B站通过RS485接收A站发送的KEY1、KEY2、KEY3按键状态保存至寄存器，同时解析寄存器数据，用来驱动LED1、LED2、LED3的亮灭。并发出应答，应答内包括B站LED1、LED2、LED3以及KEY1,KEY2状态，打包后发送至A站。
同时B站需要将LED1、LED2、LED3、KEY1、KEY2状态显示在OLED显示屏上。

## 2. 硬件配置

### 2.1 OLED显示屏 (I2C)
- 参考文献：OLED显示屏规格书，文档路径：.\STM32\ex07_Control_Handle_485_4L_rx\Doc\野火0.96寸_IIC_OLED模块规格手册_20240419 
- 通信接口：I2C1
- 引脚配置：
  - SCL: PB6
  - SDA: PB7
- 分辨率：128x64
- 地址：0x78
- 显示控制器：SSD1306
- 字库配置：
  - ASCII字库：6x8点阵
  - 字符范围：ASCII 0x20-0x7E
  - 字体数据结构：
    ```c
    // 6x8字体库数组，每个字符6字节
    const uint8_t F6x8[][6] = {
         { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // sp
    { 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00 },   // !
    { 0x00, 0x00, 0x07, 0x00, 0x07, 0x00 },   // "
    { 0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00 },   // #
    { 0x24, 0x2a, 0x7f, 0x2a, 0x12, 0x00 },   // $
    { 0x23, 0x13, 0x08, 0x64, 0x62, 0x00 },   // %
    { 0x36, 0x49, 0x55, 0x22, 0x50, 0x00 },   // &
    { 0x00, 0x05, 0x03, 0x00, 0x00, 0x00 },   // '
    { 0x00, 0x1c, 0x22, 0x41, 0x00, 0x00 },   // (
    { 0x00, 0x41, 0x22, 0x1c, 0x00, 0x00 },   // )
    { 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00 },   // *
    { 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00 },   // +
    { 0x00, 0x00, 0x50, 0x30, 0x00, 0x00 },   // ,
    { 0x08, 0x08, 0x08, 0x08, 0x08, 0x00 },   // -
    { 0x00, 0x60, 0x60, 0x00, 0x00, 0x00 },   // .
    { 0x20, 0x10, 0x08, 0x04, 0x02, 0x00 },   // /
    { 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00 },   // 0
    { 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00 },   // 1
    { 0x42, 0x61, 0x51, 0x49, 0x46, 0x00 },   // 2
    { 0x21, 0x41, 0x45, 0x4B, 0x31, 0x00 },   // 3
    { 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00 },   // 4
    { 0x27, 0x45, 0x45, 0x45, 0x39, 0x00 },   // 5
    { 0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00 },   // 6
    { 0x01, 0x71, 0x09, 0x05, 0x03, 0x00 },   // 7
    { 0x36, 0x49, 0x49, 0x49, 0x36, 0x00 },   // 8
    { 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00 },   // 9
    { 0x00, 0x36, 0x36, 0x00, 0x00, 0x00 },   // :
    { 0x00, 0x56, 0x36, 0x00, 0x00, 0x00 },   // ;
    { 0x08, 0x14, 0x22, 0x41, 0x00, 0x00 },   // <
    { 0x14, 0x14, 0x14, 0x14, 0x14, 0x00 },   // =
    { 0x00, 0x41, 0x22, 0x14, 0x08, 0x00 },   // >
    { 0x02, 0x01, 0x51, 0x09, 0x06, 0x00 },   // ?
    { 0x32, 0x49, 0x59, 0x51, 0x3E, 0x00 },   // @
    { 0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00 },   // A
    { 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00 },   // B
    { 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00 },   // C
    { 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00 },   // D
    { 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00 },   // E
    { 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00 },   // F
    { 0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00 },   // G
    { 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00 },   // H
    { 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00 },   // I
    { 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00 },   // J
    { 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00 },   // K
    { 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00 },   // L
    { 0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00 },   // M
    { 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00 },   // N
    { 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00 },   // O
    { 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00 },   // P
    { 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00 },   // Q
    { 0x7F, 0x09, 0x19, 0x29, 0x46, 0x00 },   // R
    { 0x46, 0x49, 0x49, 0x49, 0x31, 0x00 },   // S
    { 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00 },   // T
    { 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00 },   // U
    { 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00 },   // V
    { 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00 },   // W
    { 0x63, 0x14, 0x08, 0x14, 0x63, 0x00 },   // X
    { 0x07, 0x08, 0x70, 0x08, 0x07, 0x00 },   // Y
    { 0x61, 0x51, 0x49, 0x45, 0x43, 0x00 },   // Z
    { 0x00, 0x7F, 0x41, 0x41, 0x00, 0x00 },   // [
    { 0x02, 0x04, 0x08, 0x10, 0x20, 0x00 },   // "\"
    { 0x00, 0x41, 0x41, 0x7F, 0x00, 0x00 },   // ]
    { 0x04, 0x02, 0x01, 0x02, 0x04, 0x00 },   // ^
    { 0x40, 0x40, 0x40, 0x40, 0x40, 0x00 },   // _
    { 0x00, 0x01, 0x02, 0x04, 0x00, 0x00 },   // '
    { 0x20, 0x54, 0x54, 0x54, 0x78, 0x00 },   // a
    { 0x7F, 0x48, 0x44, 0x44, 0x38, 0x00 },   // b
    { 0x38, 0x44, 0x44, 0x44, 0x20, 0x00 },   // c
    { 0x38, 0x44, 0x44, 0x48, 0x7F, 0x00 },   // d
    { 0x38, 0x54, 0x54, 0x54, 0x18, 0x00 },   // e
    { 0x08, 0x7E, 0x09, 0x01, 0x02, 0x00 },   // f
    { 0x0C, 0x52, 0x52, 0x52, 0x3E, 0x00 },   // g
    { 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00 },   // h
    { 0x00, 0x44, 0x7D, 0x40, 0x00, 0x00 },   // i
    { 0x20, 0x40, 0x44, 0x3D, 0x00, 0x00 },   // j
    { 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00 },   // k
    { 0x00, 0x41, 0x7F, 0x40, 0x00, 0x00 },   // l
    { 0x7C, 0x04, 0x18, 0x04, 0x78, 0x00 },   // m
    { 0x7C, 0x08, 0x04, 0x04, 0x78, 0x00 },   // n
    { 0x38, 0x44, 0x44, 0x44, 0x38, 0x00 },   // o
    { 0x7C, 0x14, 0x14, 0x14, 0x08, 0x00 },   // p
    { 0x08, 0x14, 0x14, 0x18, 0x7C, 0x00 },   // q
    { 0x7C, 0x08, 0x04, 0x04, 0x08, 0x00 },   // r
    { 0x48, 0x54, 0x54, 0x54, 0x20, 0x00 },   // s
    { 0x04, 0x3F, 0x44, 0x40, 0x20, 0x00 },   // t
    { 0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00 },   // u
    { 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00 },   // v
    { 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00 },   // w
    { 0x44, 0x28, 0x10, 0x28, 0x44, 0x00 },   // x
    { 0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00 },   // y
    { 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00 },   // z
    { 0x00, 0x08, 0x36, 0x41, 0x00, 0x00 },   // {
    { 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00 },   // |
    { 0x00, 0x41, 0x36, 0x08, 0x00, 0x00 },   // }
    { 0x10, 0x08, 0x08, 0x10, 0x08, 0x00 },   // ~
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }    // DEL
    };
    ```
  - 字体特点：
    - 每个字符6x8像素
    - 每字节代表一列点阵
    - 1表示点亮，0表示熄灭
    - 支持95个可打印字符
  - 显示方式：
    - 垂直扫描
    - 逐列显示
    - MSB在上，LSB在下
  - 字体效果：
    - 清晰可辨
    - 适合小尺寸显示
    - 支持基本符号
- 显示布局：
  - 第1行（0-7像素）：时间和CPU使用率
  - 第2行（16-23像素）：按键状态
  - 第3行（24-31像素）：LED状态
  - 第4行（32-39像素）：通信状态
  - 第5行（40-47像素）：错误计数
  - 第6行（48-55像素）：公司信息
- 显示特性：
  - 支持双缓冲
  - 脏区域刷新
  - 动画效果
  - 局部更新

### 2.2 RS485接口 (UART3)
- 参考文献：OLED显示屏规格书，文档路径：.\STM32\ex07_Control_Handle_485_4L_rx\Doc\野火小智TTL转RS485模块规格手册_20240805.pdf
- 通信接口：USART3
- 引脚配置：
  - TX: PB11
  - RX: PB10
  - DE/RE: PB8 (方向控制，高电平发送/低电平接收)
- 芯片型号：SIT3088E
- 电气特性：
  - 工作电压：3.3V
  - 差分电压：>2V
- 接线说明：
  - A+: 485差分信号正端
  - B-: 485差分信号负端
  - GND: 信号地
- 终端电阻：
  - 120Ω (在总线两端)
- 通信距离：最大1200米
- 通信参数：
  - 波特率：115200
  - 数据位：8
  - 停止位：1
  - 校验位：无
  - 通信模式：半双工
  - 总线特性：
    - 支持多点通信
    - 抗干扰能力强
    - 传输距离远

### 2.3 调试串口 (UART1)
- 通信接口：USART1
- 引脚配置：
  - TX: PA9
  - RX: PA10
- 通信参数：同RS485

# Start of Selection
### 2.4 LED指示灯
- LED_R: PA1 (输出模式，推挽输出，低电平点亮)
- LED_G: PA2 (输出模式，推挽输出，低电平点亮)
- LED_B: PA3 (输出模式，推挽输出，低电平点亮)

### 2.5 GPIO配置
- 按键输入：
  - KEY1: PA0 (输入模式，下拉)
  - KEY2: PC13 (输入模式，下拉)
- 状态指示：
  - KEY_STATUS: PA6 (输出模式，推挽输出)
  功能：当任意按键状态发生变化时，该引脚输出一个高电平脉冲

## 3. 软件架构

### 3.1 通信协议
#### RS485数据帧格式
从站接收报文格式：
遵照Modbus RTU报文格式，即：
请求报文（B站发出）	地址码（1B） + 功能码（1B） + 数据域（N字节） + CRC校验（2B）
正常响应报文（B站应答）	地址码（1B） + 功能码（1B） + 数据域（带数据长度） + CRC校验（2B）
异常响应报文（B站应答）	地址码（1B） + 异常功能码（1B，原功能码+0x80） + 异常码（1B） + CRC校验（2B）


从站存储区分类
1. 线圈（Coils）
类型：位（Bit）
范围：0x0000 - 0xFFFF
描述：用于表示开关状态（如开/关），可以读写。
离散输入（Discrete Inputs）
类型：位（Bit）
范围：0x0000 - 0xFFFF
描述：用于表示输入状态（如传感器状态），只能读取。
3. 保持寄存器（Holding Registers）
类型：16位（Word）
范围：0x0000 - 0xFFFF
描述：用于存储可读写的数据（如设置值、配置参数等）。
输入寄存器（Input Registers）
类型：16位（Word）
范围：0x0000 - 0xFFFF
描述：用于存储只读的数据（如传感器读数）。

存储区的访问方式
读操作：可以通过功能码读取存储区的数据。
写操作：可以通过功能码写入数据到保持寄存器和线圈。

### 命令定义
遵循标准ModbusRTU协议，功能码定义如下：
  功能码定义
| 功能码 | 功能描述 |
|--------|------------------------------|
| 0x01 | 读线圈状态 |
| 0x02 | 读离散输入状态 |
| 0x03 | 读保持寄存器 |
| 0x04 | 读输入寄存器 |
| 0x05 | 写单个线圈 |
| 0x06 | 写单个保持寄存器 |
| 0x0F | 写多个线圈 |
| 0x10 | 写多个保持寄存器 |
| 0x11 | 读设备标识 |
| 0x14 | 读FIFO队列 |
| 0x16 | 写多个单元 |
| 0x17 | 读/写多个寄存器 |
异常功能码
| 功能码 | 功能描述 |
|--------|------------------------------|
| 0x80 | 异常响应功能码 |
| 0x01 | 非法功能 |
| 0x02 | 非法数据地址 |
| 0x03 | 非法数据值 |
| 0x04 | 从站设备故障 |
| 0x05 | ACK（确认） |
| 0x06 | 设备忙 |
| 0x07 | 负载超限 |

# 代码逻辑

## 从站代码工作逻辑总结

从站代码工作逻辑总结

1. 初始化阶段
   - 初始化硬件接口
     - I2C和USART3（RS485）
     - GPIO引脚配置
     - LED指示灯
     - OLED显示屏
   - 存储区初始化
     - 定义存储区类型
     - 分配内存空间
     - 初始值设置为0
   - 按键状态变化指示
     - GPIO引脚配置为输出
     - 用于指示按键状态变化

2. 主循环
   - 监测通信状态和按键输入
   - 定期更新OLED显示
     - LED状态
     - 按键状态
     - 通信状态
   - 按键状态检测
     - 持续扫描按键
     - 状态变化时产生脉冲信号
     - 通知主站

3. 通信处理
   - 接收处理
     - 通过USART3接收主站报文
     - 解析报文内容
     - 提取地址码、功能码和数据
   - 操作执行
     - 读操作：获取存储区数据
     - 写操作：更新存储区数据
     - 打包响应报文

4. 状态更新
   - 按键状态更新
     - 更新KEY1、KEY2、KEY3寄存器
   - LED控制
     - 根据寄存器控制LED1、LED2、LED3
   - OLED显示更新
     - 实时显示各状态信息

5. 异常处理
   - 报文解析错误处理
   - 非法功能码处理
   - 非法数据地址处理
   - 生成异常响应报文

6. 监控与反馈
   - 通信状态监控
   - 错误计数记录
   - OLED信息显示
     - 实时性保证
     - 准确性确保

总结：
从站基于Modbus RTU协议工作，主要完成：
- 处理主站请求
- 更新内部状态
- OLED状态显示
- 通过使用独立的IO口指示按键状态变化，从站能够在按键状态变化时主动通知主站，主站在检测到该信号后主动请求从站的状态。
- 代码结构清晰，功能模块化，便于维护和扩展。

## 代码结构
### 核心文件
1. 通信模块 (RS485从站实现)
   - comm.h/comm.c：Modbus RTU从站协议实现
     - 接收主站请求报文解析
     - 按键状态和LED控制数据处理
     - 响应报文打包发送
     - CRC校验和错误处理
   - usart.h/usart.c：串口驱动
     - USART3配置(RS485)
     - 发送/接收缓冲区管理
     - DE/RE方向控制

2. 显示模块 (OLED状态显示)
   - oled.h/oled.c：OLED驱动实现
     - I2C通信接口
     - 显示缓冲区管理
     - 字符显示函数
   - display.h/display.c：显示逻辑
     - LED状态显示
     - 按键状态显示
     - 通信状态显示
     - 错误计数显示

3. 主程序和外设控制
   - main.c：系统初始化和主循环
     - 外设初始化
     - 任务调度
   - gpio.h/gpio.c：IO口控制
     - LED控制接口
     - 按键扫描
     - 状态指示
   - timer.h/timer.c：定时器
     - 通信超时检测
     - 按键消抖(已由硬件实现)
     - 显示刷新

## 关键技术实现
1. OLED显示管理
   - 采用I2C通信方式,配置为主机模式
   - 使用6x8点阵ASCII字库显示字符
   - 显示内容包括:
     - LED1-3状态显示
     - KEY1-2状态显示
     - 通信状态指示
     - 错误计数显示

2. Modbus RTU从站通信
   - USART3配置为中断接收模式
   - 通信协议:
     - 波特率115200
     - 8位数据位
     - 1位停止位
     - 无校验位
   - 报文处理:
     - 接收主站请求解析
     - CRC校验错误检测
     - 响应报文打包发送
   - 数据处理:
     - 按键状态保存至寄存器
     - LED控制数据解析执行
     - 状态打包应答

3. 系统任务管理
   - 定时器配置:
     - 通信超时检测
     - OLED定时刷新
   - 状态监控:
     - 通信错误统计
     - LED和按键状态更新
     - OLED显示实时更新

## 性能指标
- 显示刷新率：60Hz
- 通信波特率：115200
- 响应时间：<10ms
- CPU占用率：实时显示

## 注意事项
1. 硬件连接
   - I2C需要外部上拉电阻（4.7K）
   - 485需要合适的终端电阻
   - 电源要求稳定5V供电

2. 软件配置
   - 需要正确配置通信波特率
   - 注意通信超时设置
   - 关注CPU使用率

## 维护记录
- 版本：V1.0.0
- 

## 后续计划


2. 性能优化


## 参考资料
1. STM32F103数据手册
2. OLED显示屏规格书
3. MAX485数据手册
4. HAL库使用手册

